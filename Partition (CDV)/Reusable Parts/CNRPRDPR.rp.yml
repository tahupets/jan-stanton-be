Reusable Part:
  Name:               CNRPRDPR
  Enabled For RDMLX:  Yes
  Target Platform:    Windows/IBM i/Linux

  Multilingual Details:
  - ENG:
      Description:        "Products Processor"

  Source: |
    * ========================================================
    * Copyright       : (C) Lansa Commerce Edition, 2018
    * Type            : Reusable Part
    * Platform        : Web Application (Visual LANSA)
    * Name            : CNRPRDPR
    * Identifier      : CNRPRDPR
    * Ancestor        : PRIM_OBJT
    * Written By      : Jerson Dela Cruz
    * Written On      : 6th May 2025
    * Description     : Products Processor
    * =======================================================
    * Modification Log
    * -------------------------------------------------------
    * User       : Date       : Description (Inc App Trkr #)
    * -------------------------------------------------------
    *
    * =======================================================
    
    Function Options(*DIRECT)
    Begin_Com Role(*EXTENDS #PRIM_OBJT)
    
    * =======================================================
    * Global Objects
    * =======================================================
    
    Define_Com Class(#CNRDTAMD) Name(#Global_DataModel) Desc('Global Data Model') Help('Global Data Model') Scope(*APPLICATION)
    Define_Com Class(#LW3CNTGL) Name(#Global_Constants) Desc('Global Constants') Help('Global Constants') Scope(*APPLICATION)
    
    * =======================================================
    * Utilities
    * =======================================================
    
    Define_Com Class(#CERGNUTL) Name(#Utility_General) Desc('CE General Utility') Help('CE General Utility') Scope(*APPLICATION)
    Define_Com Class(#CERSSUTL) Name(#Utility_SystemSettings) Desc('System Settings Utility') Help('System Settings Utility') Scope(*APPLICATION)
    Define_Com Class(#CNRCODES) Name(#Utility_Codes) Desc('Code Table Utility') Help('Code Table Utility') Scope(*APPLICATION)
    
    * =======================================================
    * Local Variable Definitions
    * =======================================================
    
    Define_Com Class(#LW3WEBC01) Name(#L_CustomerIdForQuery)
    Define_Com Class(#PRIM_ALPH) Name(#L_ActivePriceFileLibrary)
    
    * =======================================================
    * Method Definitions
    * =======================================================
    * =======================================================
    * Mthroutine  : umGetProductDetails
    * Description : Read LFIP100 to get Product Information for the passed in parameters
    * =======================================================
    Mthroutine Name(umGetProductDetails) Desc('Get Product Details') Help('Read LFIP100 to get Product Information for the passed in parameters')
    
    Define_Map For(*INPUT) Class(#PRIM_LCOL<#CNRPRDDO>) Name(#iProductList) Pass(*BY_REFERENCE)
    Define_Map For(*INPUT) Class(#LW3SFID) Name(#iStorefrontId)
    Define_Map For(*INPUT) Class(#LW3B2BIND) Name(#iStorefrontIndicator)
    Define_Map For(*INPUT) Class(#LW3STYLE) Name(#iStyleCode) Mandatory('')
    Define_Map For(*INPUT) Class(#LW3COLOR) Name(#iColorCode) Mandatory('')
    Define_Map For(*INPUT) Class(#LW3SIZE) Name(#iSizeCode) Mandatory('')
    Define_Map For(*INPUT) Class(#LW3BACK) Name(#iBackingCode) Mandatory('')
    Define_Map For(*INPUT) Class(#LW3SDESC) Name(#iStyleDescription) Mandatory('')
    Define_Map For(*INPUT) Class(#LW3CDESC) Name(#iColorDescription) Mandatory('')
    Define_Map For(*INPUT) Class(#PRIM_BOLN) Name(#iSwatchSearch) Mandatory(False)
    Define_Map For(*INPUT) Class(#PRIM_BOLN) Name(#iNewItemIndicator) Mandatory(False)
    
    Define_Map For(*OUTPUT) Class(#LW3RETCOD) Name(#oReturnCode)
    
    * Set the format for Customer Id to be used in the query. Stanton Customer Ids are 6 digit characters with leading zeroes
    If Cond(#Global_DataModel.upCustomerId = *BLANKS)
    #L_CustomerIdForQuery := '0'
    Else
    #L_CustomerIdForQuery := #Global_DataModel.upCustomerId.RightAdjust( 6 '0' ).Trim
    Endif
    
    * Get Active Pricing File
    #Utility_SystemSettings.umRetrieveSystemVariable Ivariable('ACTIVE_PRICING_FILE') Ilanguage('') Oalphavalue(#L_ActivePriceFileLibrary)
    
    If Cond(#iStorefrontIndicator = 'B')
    
    * If New Item, use a different query
    If Cond(#iNewItemIndicator)
    
    #COM_OWNER.umGetDetailsForNewItemB2B Iproductlist(#iProductList) Istorefrontid(#iStorefrontId) Istorefrontindicator(#iStorefrontIndicator) Inewitemindicator(#iNewItemIndicator)
    Else
    
    #COM_OWNER.umGetDetailsForB2BProduct Iproductlist(#iProductList) Istorefrontid(#iStorefrontId) Istorefrontindicator(#iStorefrontIndicator) Istylecode(#iStyleCode) Icolorcode(#iColorCode) Isizecode(#iSizeCode) Ibackingcode(#iBackingCode)
    
    Endif
    
    Else
    
    #COM_OWNER.umGetDetailsForB2CProduct Iproductlist(#iProductList) Istorefrontid(#iStorefrontId) Istorefrontindicator(#iStorefrontIndicator) Istylecode(#iStyleCode) Icolorcode(#iColorCode) Isizecode(#iSizeCode) Ibackingcode(#iBackingCode)
    
    Endif
    
    If Cond(#iProductList.ItemCount = 0)
    #oReturnCode := 'ER'
    Else
    #oReturnCode := 'OK'
    Endif
    
    * !NC! - Continue logic here later
    
    * * * #W_PRODUCTTYPE := #L00PTYP
    * * *
    * * * * Only retrieve coordinates/available colors if product details were found
    * * * If Cond((#FXDTARCD = 'ALL') And (#LISTCOUNT > 0))
    * * * #W_STYLECODE := #L00STYLE
    * * * #W_COLORCODE := #L00COLOR
    * * * #W_SIZECODE := #L00SIZE
    * * * #W_BACKINGCODE := #L00BACK
    * * * * Pass in the previously retrieved product key fields
    * * *
    * * * * Check_For In_File(LW3CODL4) With_Key('HSBRND' *LANGUAGE #L00DVBR) Io_Error(*NEXT)
    * * * * If_Status Is(*EQUALKEY)
    * * * If Cond((#L00DVBR = 'SHS') Or (#L00DVBR = 'SST'))
    * * * * 04/08/2020 - If getting product details for a Hard surface product, get coordinating broadlooms
    * * * #COM_OWNER.umGetCoordinatingBroadloom Igetpricedproducts((#FXCUSIND = 'B') And (#LW3NITMF <> 'Y')) Istylecode(#W_STYLECODE) Icolorcode(#W_COLORCODE)
    * * * Else
    * * * #COM_OWNER.umGetCoordinates Igetpricedproducts((#FXCUSIND = 'B') And (#LW3NITMF <> 'Y')) Istylecode(#W_STYLECODE) Icolorcode(#W_COLORCODE) Isizecode(#W_SIZECODE) Ibackingcode(#W_BACKINGCODE) Iproductcollection(#L00CNAME) Iproducttype(#L00PTYP)
    * * * Endif
    * * *
    * * * * #134
    * * * * Modified by Jan - 4th Nov 2022 - GitLab Issue #227
    * * * * If Cond((#W_PRODUCTTYPE = 'H') Or (#W_PRODUCTTYPE = 'I') Or (#W_PRODUCTTYPE = #Global_Constants.upPrdTyp_Porcelain) Or (#W_PRODUCTTYPE = #Global_Constants.upPrdTyp_Laminate))
    * * * * G#151
    * * * If Cond((#W_PRODUCTTYPE = #Global_Constants.upPrdTyp_HardSurfacePlank) Or (#W_PRODUCTTYPE = #Global_Constants.upPrdTyp_HardSurfaceTile) Or (#W_PRODUCTTYPE = #Global_Constants.upPrdTyp_Porcelain) Or (#W_PRODUCTTYPE = #Global_Constants.upPrdTyp_Laminate) Or (#W_PRODUCTTYPE = #Global_Constants.upPrdTyp_FineHardwood))
    * * * #COM_OWNER.umGetCoordinatingTrims Istylecode(#W_STYLECODE) Icolorcode(#W_COLORCODE)
    * * * Endif
    * * *
    * * * * #134
    * * * * Modified by Jan - 4th Nov 2022 - GitLab Issue #254
    * * * * If Cond(#W_PRODUCTTYPE = 'M')
    * * * If Cond(#Global_Constants.umIsCoordinatingProduct( #W_PRODUCTTYPE ))
    * * * * For Molding Trim, get Available Styles instead of Available Colors
    * * * #COM_OWNER.umGetAvailableStyles Igetpricedproducts((#FXCUSIND = 'B') And (#LW3NITMF <> 'Y')) Istylecode(#W_STYLECODE) Icolorcode(#W_COLORCODE) Isizecode(#W_SIZECODE) Ibackingcode(#W_BACKINGCODE)
    * * * Else
    * * * #COM_OWNER.umGetAvailableColors Igetpricedproducts((#FXCUSIND = 'B') And (#LW3NITMF <> 'Y')) Istylecode(#W_STYLECODE) Icolorcode(#W_COLORCODE) Isizecode(#W_SIZECODE) Ibackingcode(#W_BACKINGCODE)
    * * * Endif
    * * *
    * * * Endif
    * * *
    * * * * If Premade Rugs, retrieve the available lengths - retrieve only if product details were found
    * * * If Cond((#W_PRODUCTTYPE = 'R') And (#LISTCOUNT > 0))
    * * *
    * * * #LW3ROWTYP := 'ALN'
    * * *
    * * * * Retrieve Available Lengths
    * * * If Cond(#FXCUSIND = 'B')
    * * * * G#35
    * * * * #LW3QSEL := "SELECT ATTR.L00DVBR, ATTR.L00STYLE, ATTR.L00COLOR, ATTR.L00SIZE, ATTR.L00BACK, ATTR.L00PTYP, ATTR.L00SDESC, ATTR.L00CDESC, ATTR.L00WDTIN, ATTR.L00LTHIN, ATTR.L00FLAG5, PRICE.P010RPRC, PRICE.P010CPRC FROM LFIP100 ATTR JOIN " + #LW3ACTFIL + " PRICE ON ATTR.L00STYLE = PRICE.P010STYL AND ATTR.L00SIZE = PRICE.P010SIZE AND ATTR.L00BACK = PRICE.P010BACK WHERE PRICE.P010SID# = 0 AND ATTR.L00SDESC = '" + #FXSTYLDS + "' AND ATTR.L00CDESC = '" + #FXCOLRDS + "' AND PRICE.P010CPRC > 0 AND PRICE.P010CST# = " + #FXCUSID.Trim + #COM_OWNER.umAttachFiltersToQuery( True ) + #COM_OWNER.umCheckProprietary + " ORDER BY PRICE.P010CPRC"
    * * * #LW3QSEL := "SELECT ATTR.L00DVBR, ATTR.L00STYLE, ATTR.L00COLOR, ATTR.L00SIZE, ATTR.L00BACK, ATTR.L00PTYP, ATTR.L00SDESC, ATTR.L00CDESC, ATTR.L00WDTIN, ATTR.L00LTHIN, ATTR.L00FLAG5, PRICE.P010RPRC, PRICE.P010CPRC FROM LFIP100 ATTR JOIN " + #LW3ACTFIL + " PRICE ON ATTR.L00STYLE = PRICE.P010STYL AND ATTR.L00SIZE = PRICE.P010SIZE AND ATTR.L00BACK = PRICE.P010BACK WHERE PRICE.P010SID# = 0 AND ATTR.L00SDESC = '" + #FXSTYLDS + "' AND ATTR.L00CDESC = '" + #FXCOLRDS + "' AND PRICE.P010CST# = " + #FXCUSID.Trim + #COM_OWNER.umAttachFiltersToQuery( True ) + #COM_OWNER.umCheckProprietary + " ORDER BY PRICE.P010CPRC"
    * * *
    * * * * * !NC! - Premade Rug B2B
    * * * * #COM_OWNER.umSQLDebugMessage Iheadermessage('Premade Rug B2B') Iquerystring(#LW3QSEL)
    * * *
    * * * Select_Sql Fields(#L00DVBR #L00STYLE #L00COLOR #L00SIZE #L00BACK #L00PTYP #L00SDESC #L00CDESC #L00WDTIN #L00LTHIN #L00FLAG5 #P010RPRC #P010CPRC) Io_Error(*NEXT) Using(#LW3QSEL)
    * * * If Cond(#LW3MSRPPF = 'Y')
    * * * * G#35
    * * * #Utility_API.umGetPrice( #FXCUSID #L00STYLE #L00COLOR #L00SIZE #L00BACK 'Y' #P010CPRC #P010RPRC #P010SMPRC #P010SHPRC #OPPEDATE #OPPAPLY #FXCUSIND )
    * * *
    * * * #P010CPRC := ((#LW3MSRPPR / 100) * #P010CPRC) + #P010CPRC
    * * * Endif
    * * * Add_Entry To_List(#WL_PRDLST)
    * * * Endselect
    * * *
    * * * Else
    * * * * #LW3QSEL := "SELECT ATTR.L00DVBR, ATTR.L00STYLE, ATTR.L00COLOR, ATTR.L00SIZE, ATTR.L00BACK, ATTR.L00PTYP, ATTR.L00SDESC, ATTR.L00CDESC, ATTR.L00WDTIN, ATTR.L00LTHIN FROM LFIP100 AS ATTR WHERE ATTR.L00SDESC = '" + #FXSTYLDS + "' AND ATTR.L00CDESC = '" + #FXCOLRDS + "'" + #COM_OWNER.umAttachFiltersToQuery( True ) + #COM_OWNER.umCheckProprietary
    * * *
    * * * * AppTracker Issue #12615 - Do not include dropped colors for Premade Rugs
    * * * #LW3QSEL := "SELECT ATTR.L00DVBR, ATTR.L00STYLE, ATTR.L00COLOR, ATTR.L00SIZE, ATTR.L00BACK, ATTR.L00PTYP, ATTR.L00SDESC, ATTR.L00CDESC, ATTR.L00WDTIN, ATTR.L00LTHIN FROM LFIP100 AS ATTR WHERE ATTR.L00SDESC = '" + #FXSTYLDS + "' AND ATTR.L00CDESC = '" + #FXCOLRDS + "'" + #COM_OWNER.umAttachFiltersToQuery( True ) + #COM_OWNER.umCheckProprietary + " AND ((ATTR.L00PTYP <> 'R') Or (ATTR.L00PTYP = 'R' AND L00DROP <> 'Y'))"
    * * *
    * * * * * !NC! - Premade Rug B2C
    * * * * #COM_OWNER.umSQLDebugMessage Iheadermessage('Premade Rug B2C') Iquerystring(#LW3QSEL)
    * * *
    * * * Select_Sql Fields(#L00DVBR #L00STYLE #L00COLOR #L00SIZE #L00BACK #L00PTYP #L00SDESC #L00CDESC #L00WDTIN #L00LTHIN) Io_Error(*NEXT) Using(#LW3QSEL)
    * * * Add_Entry To_List(#WL_PRDLST)
    * * * Endselect
    * * *
    * * * Endif
    * * *
    * * * Endif
    * * *
    * * * * check value of field #LW3CRDVIS
    * * * If Cond(#LW3CRDVIS *EQ 'Y')
    * * * #F55UPRICE #F55UPRCCA #P010SHPRC #P010SMPRC #P010CPRC #P010RPRC := 0
    * * * Endif
    
    Endroutine
    
    * =======================================================
    * Mthroutine  : umGetDetailsForNewItemB2B
    * Description : Read LFIP100 to get Product Information only for New Items in B2B
    * =======================================================
    Mthroutine Name(umGetDetailsForNewItemB2B) Desc('Get Product Details') Help('Read LFIP100 to get Product Information only for New Items in B2B')
    
    Define_Map For(*INPUT) Class(#PRIM_LCOL<#CNRPRDDO>) Name(#iProductList) Pass(*BY_REFERENCE)
    Define_Map For(*INPUT) Class(#LW3SFID) Name(#iStorefrontId)
    Define_Map For(*INPUT) Class(#LW3B2BIND) Name(#iStorefrontIndicator)
    Define_Map For(*INPUT) Class(#LW3SDESC) Name(#iStyleDescription) Mandatory('')
    Define_Map For(*INPUT) Class(#LW3CDESC) Name(#iColorDescription) Mandatory('')
    Define_Map For(*INPUT) Class(#PRIM_BOLN) Name(#iSwatchSearch) Mandatory(False)
    Define_Map For(*INPUT) Class(#PRIM_BOLN) Name(#iNewItemIndicator) Mandatory(False)
    
    #LW3QSEL := "SELECT DISTINCT ATTR.*, CASE WHEN ATTR.L00PTYP In ('W', 'S') Then 1 Else 0 End As PRDTYPSORT FROM LFIP100 AS ATTR"
    * #134
    #LW3QSEL += " Left Join LFIP100A ATR2 ON ATR2.L0ADVBR = ATTR.L00DVBR And ATR2.L0APCAT = ATTR.L00PCAT And ATR2.L0ACNAME = ATTR.L00CNAME And ATR2.L0ASTYLE = ATTR.L00STYLE And ATR2.L0ACOLOR = ATTR.L00COLOR And ATR2.L0ASIZE = ATTR.L00SIZE And ATR2.L0ABACK = ATTR.L00BACK"
    #LW3QSEL += " JOIN CIP500 AS CUSTBRAND ON CUSTBRAND.C5CUST = " + #L_CustomerIdForQuery + " AND CUSTBRAND.C5DVBR = ATTR.L00DVBR"
    
    * !NC! - 2025/08/18 - Jan - Check the difference between #FXSWONLY and #LW3SWSRF later. Maybe these can be made into just one parameter
    * If Cond(#FXSWONLY = 'Y')
    If Cond(#iSwatchSearch)
    * Use color code
    #LW3QSEL += " WHERE ATTR.L00SDESC = '" + #iStyleDescription + "' AND ATTR.L00COLOR = '" + #iColorDescription + "'"
    Else
    * Use color desc
    #LW3QSEL += " WHERE ATTR.L00SDESC = '" + #iStyleDescription + "' AND ATTR.L00CDESC = '" + #iColorDescription + "'"
    Endif
    
    * #152
    If Cond(*Not #iSwatchSearch)
    #LW3QSEL += " AND (ATTR.L00PTYP <> 'W' AND ATTR.L00PTYP <> 'S')"
    Endif
    
    #LW3QSEL += " ORDER BY PRDTYPSORT"
    
    Select_Sql Fields(#L00DVBR #L00PCAT #L00CNAME #L00STYLE #L00COLOR #L00SIZE #L00BACK #L00PTYP #L00SDESC #L00CDESC #L00WTHFT #L00WTHIN #L00BDESC #L00STDLTH #L00PRDG #L00F2F #L00DROP #L00DROPDT #L00PROPRI #L00PROPCU #L00PROPB2 #L00CLR1 #L00CLR2 #L00PATRNR #L00CONSTR #L00LOOK #L00USAGE #L00FIBER1 #L00FIBER2 #L00FIBER3 #L00PATERN #L00PAT001 #L00FIBRLB #L00CPYRGT #L00MXWTHF #L00MXWTHI #L00SKUSEQ #L00INTROD #L00IMGFLA #L00IMGPRO #L00RMSCEN #L00RMS001 #L00RMS002 #L00IMGGRO #L00FLATCL #L00FLATRN #L00PROFCL #L00PROFRN #L00RM1CLR #L00RM1RNK #L00RM2CLR #L00RM2RNK #L00RM3CLR #L00RM3RNK #L00GROPCL #L00GROPRN #L00ROLONL #L00RPC #L00PATPRD #L00CHAR1 #L00CHAR2 #L00CHAR3 #L00CHAR4 #L00CHAR5 #L00FLAG1 #L00FLAG2 #L00FLAG3 #L00FLAG4 #L00FLAG5 #L00INT1 #L00INT2 #L00INT3 #L00INT4 #L00INT5 #L00DEC1 #L00DEC2 #L00DEC3 #L00DEC4 #L00DEC5 #L00COLCD #L00ROOMTY #L00ROO001 #L00ROO002 #L00WDTIN #L00LTHIN #LW3SORTOR) Io_Error(*NEXT) Using(#LW3QSEL)
    
    Continue If((#L00PROPRI = 'Y') And (#L00PROPCU <> #FXCUSID.AsNumber))
    
    * Retrieve Pricing
    #LW3QSEL := ''
    Select_Sql Fields(#P010RPRC #P010CPRC #P010UOM) Using("SELECT P010RPRC, P010CPRC, P010UOM FROM " + #LW3ACTFIL + " WHERE P010SID# = 0 AND P010CST# = " + #FXCUSID.Trim + " AND P010STYL = '" + #L00STYLE + "' AND P010SIZE = '" + #L00SIZE + "' AND P010BACK = '" + #L00BACK + "'")
    * !NC! - Apply Pricing Later
    * * * * G#35 - Use new API to get pricing
    * * * #COM_OWNER.umGetPrice( #FXCUSID #L00STYLE #L00COLOR #L00SIZE #L00BACK 'Y' #P010CPRC #P010RPRC #P010SMPRC #P010SHPRC #OPPEDATE #OPPAPLY #FXCUSIND )
    
    If Cond(#FXOLNTYP = 'RG')
    #LW3VARTXT := 'CUSTOMRUG'
    Else
    #LW3VARTXT := 'PRODUCTTYPE'
    Endif
    
    * !NC! - Apply Markups Later
    * * * #MarkupUtility.umApplyMarkup Iretailpricingflag(#LW3MSRPPF) Imarkupapplicationtype(#LW3VARTXT) Iorderlinetype(#FXOLNTYP) Imarkupcarpet(#LW3MSRPCP) Imarkuppremaderug(#LW3MSRPPR) Imarkupcustomrug(#LW3MSRPCR) Imarkupcarpettile(#LW3MSRPTL) Imarkuphardsurface(#LW3MSRPHS) Iproducttype(#L00PTYP) Bcalculatedprice(#P010CPRC)
    
    Leave
    Endselect
    
    Add_Entry To_List(#iProductList)
    
    * This should only retrieve one entry
    Leave
    Endselect
    
    Endroutine
    
    * =======================================================
    * Mthroutine  : umGetDetailsForB2BProduct
    * Description : Read LFIP100 and LPRP0010 to get Product Information for items in B2B
    * =======================================================
    Mthroutine Name(umGetDetailsForB2BProduct) Desc('Get Product Details') Help('Read LFIP100 and LPRP0010 to get Product Information for items in B2B') Access(*PRIVATE)
    
    Define_Map For(*INPUT) Class(#PRIM_LCOL<#CNRPRDDO>) Name(#iProductList) Pass(*BY_REFERENCE)
    Define_Map For(*INPUT) Class(#LW3SFID) Name(#iStorefrontId)
    Define_Map For(*INPUT) Class(#LW3B2BIND) Name(#iStorefrontIndicator)
    Define_Map For(*INPUT) Class(#LW3STYLE) Name(#iStyleCode) Mandatory('')
    Define_Map For(*INPUT) Class(#LW3COLOR) Name(#iColorCode) Mandatory('')
    Define_Map For(*INPUT) Class(#LW3SIZE) Name(#iSizeCode) Mandatory('')
    Define_Map For(*INPUT) Class(#LW3BACK) Name(#iBackingCode) Mandatory('')
    
    Define_Map For(*INPUT) Class(#LW3SDESC) Name(#iStyleDescription) Mandatory('')
    Define_Map For(*INPUT) Class(#LW3CDESC) Name(#iColorDescription) Mandatory('')
    Define_Map For(*INPUT) Class(#PRIM_BOLN) Name(#iSwatchSearch) Mandatory(False)
    Define_Map For(*INPUT) Class(#LW3OLNTYP) Name(#iOrderLineType) Mandatory('')
    
    * * * * If product detail keys supplied is style and color description (from friendly URL), use them to get product information
    * * * If Cond(#FXFNDURL = 'Y')
    
    * !NC! - Only difference between the query in #iSwatchSearch is that L00COLOR = #iColorDescription which seems incorrect. Analyze the existing code for whether this is used or not
    * * * If Cond(#iSwatchSearch)
    * * * * #134
    * * * * G#35 DISTINCT
    * * * #LW3QSEL := "SELECT DISTINCT ATTR.*, PRICE.P010RPRC, PRICE.P010CPRC, PRICE.P010UOM, PRICE.P010SMPRC, PRICE.P010SHPRC FROM LFIP100 ATTR"
    * * * #LW3QSEL += " Left Join LFIP100A ATR2 ON ATR2.L0ADVBR = ATTR.L00DVBR And ATR2.L0APCAT = ATTR.L00PCAT And ATR2.L0ACNAME = ATTR.L00CNAME And ATR2.L0ASTYLE = ATTR.L00STYLE And ATR2.L0ACOLOR = ATTR.L00COLOR And ATR2.L0ASIZE = ATTR.L00SIZE And ATR2.L0ABACK = ATTR.L00BACK"
    * * * * G#35
    * * * #LW3QSEL += " JOIN " + #L_ActivePriceFileLibrary + " PRICE ON ATTR.L00STYLE = PRICE.P010STYL AND ATTR.L00SIZE = PRICE.P010SIZE AND ATTR.L00BACK = PRICE.P010BACK WHERE PRICE.P010SID# = 0 AND ATTR.L00SDESC = '" + #iStyleDescription + "' AND ATTR.L00COLOR = '" + #iColorDescription + "' AND PRICE.P010CST# = " + #L_CustomerIdForQuery + #COM_OWNER.umCheckProprietary
    * * *
    * * * Else
    * Use color description
    * #134
    * G#35 DISTINCT
    #LW3QSEL := "SELECT DISTINCT ATTR.*, PRICE.P010RPRC, PRICE.P010CPRC, PRICE.P010UOM, PRICE.P010SMPRC, PRICE.P010SHPRC FROM LFIP100 ATTR"
    #LW3QSEL += " Left Join LFIP100A ATR2 ON ATR2.L0ADVBR = ATTR.L00DVBR And ATR2.L0APCAT = ATTR.L00PCAT And ATR2.L0ACNAME = ATTR.L00CNAME And ATR2.L0ASTYLE = ATTR.L00STYLE And ATR2.L0ACOLOR = ATTR.L00COLOR And ATR2.L0ASIZE = ATTR.L00SIZE And ATR2.L0ABACK = ATTR.L00BACK"
    * G#35
    #LW3QSEL += " JOIN " + #L_ActivePriceFileLibrary + " PRICE ON ATTR.L00STYLE = PRICE.P010STYL AND ATTR.L00SIZE = PRICE.P010SIZE AND ATTR.L00BACK = PRICE.P010BACK WHERE PRICE.P010SID# = 0 AND ATTR.L00SDESC = '" + #iStyleDescription + "' AND ATTR.L00CDESC = '" + #iColorDescription + "' AND PRICE.P010CST# = " + #L_CustomerIdForQuery + #COM_OWNER.umCheckProprietary
    
    * * * Endif
    
    * * * Else
    * Is already using color code
    * #134
    * G#35 DISTINCT
    #LW3QSEL := "SELECT DISTINCT ATTR.*, PRICE.P010RPRC, PRICE.P010CPRC, PRICE.P010UOM, PRICE.P010SMPRC, PRICE.P010SHPRC FROM LFIP100 ATTR"
    #LW3QSEL += " Left Join LFIP100A ATR2 ON ATR2.L0ADVBR = ATTR.L00DVBR And ATR2.L0APCAT = ATTR.L00PCAT And ATR2.L0ACNAME = ATTR.L00CNAME And ATR2.L0ASTYLE = ATTR.L00STYLE And ATR2.L0ACOLOR = ATTR.L00COLOR And ATR2.L0ASIZE = ATTR.L00SIZE And ATR2.L0ABACK = ATTR.L00BACK"
    * G#35
    #LW3QSEL += " JOIN " + #L_ActivePriceFileLibrary + " PRICE ON ATTR.L00STYLE = PRICE.P010STYL AND ATTR.L00SIZE = PRICE.P010SIZE AND ATTR.L00BACK = PRICE.P010BACK WHERE PRICE.P010SID# = 0 AND ATTR.L00STYLE = '" + #iStyleCode + "' AND ATTR.L00COLOR = '" + #iColorCode + "' AND ATTR.L00SIZE = '" + #iSizeCode + "' AND ATTR.L00BACK = '" + #iBackingCode + "' AND PRICE.P010CST# = " + #L_CustomerIdForQuery + #COM_OWNER.umCheckProprietary
    * * * Endif
    
    * Exclude swatches from selection
    If Cond(*Not #iSwatchSearch)
    #LW3QSEL += " AND ATTR.L00PTYP NOT IN ('W', 'S')"
    Endif
    
    * !NC! - 08/18/2025 - Jan - Not sure why there is logic to ignore dropped products and assuming that the select query below will return more than one record
    * * * * 2021/08/05 - Gitlab#31 - Initialize indicator to True
    * * * #wCompletelyDroppedFlag := True
    
    Select_Sql Fields(#L00DVBR #L00PCAT #L00CNAME #L00STYLE #L00COLOR #L00SIZE #L00BACK #L00PTYP #L00SDESC #L00CDESC #L00WTHFT #L00WTHIN #L00BDESC #L00STDLTH #L00PRDG #L00F2F #L00DROP #L00DROPDT #L00PROPRI #L00PROPCU #L00PROPB2 #L00CLR1 #L00CLR2 #L00PATRNR #L00CONSTR #L00LOOK #L00USAGE #L00FIBER1 #L00FIBER2 #L00FIBER3 #L00PATERN #L00PAT001 #L00FIBRLB #L00CPYRGT #L00MXWTHF #L00MXWTHI #L00SKUSEQ #L00INTROD #L00IMGFLA #L00IMGPRO #L00RMSCEN #L00RMS001 #L00RMS002 #L00IMGGRO #L00FLATCL #L00FLATRN #L00PROFCL #L00PROFRN #L00RM1CLR #L00RM1RNK #L00RM2CLR #L00RM2RNK #L00RM3CLR #L00RM3RNK #L00GROPCL #L00GROPRN #L00ROLONL #L00RPC #L00PATPRD #L00CHAR1 #L00CHAR2 #L00CHAR3 #L00CHAR4 #L00CHAR5 #L00FLAG1 #L00FLAG2 #L00FLAG3 #L00FLAG4 #L00FLAG5 #L00INT1 #L00INT2 #L00INT3 #L00INT4 #L00INT5 #L00DEC1 #L00DEC2 #L00DEC3 #L00DEC4 #L00DEC5 #L00COLCD #L00ROOMTY #L00ROO001 #L00ROO002 #L00WDTIN #L00LTHIN #P010RPRC #P010CPRC #P010UOM #P010SMPRC #P010SHPRC) Io_Error(*NEXT) Using(#LW3QSEL)
    
    * !NC! - Apply Pricing Later
    * * * * G#35 - Use the API to get the pricing field values
    * * * #Utility_API.umGetPrice( #FXCUSID #L00STYLE #L00COLOR #L00SIZE #L00BACK 'Y' #P010CPRC #P010RPRC #P010SMPRC #P010SHPRC #OPPEDATE #OPPAPLY #FXCUSIND )
    
    If Cond(#iOrderLineType = 'RG')
    #FXVARTXT := 'CUSTOMRUG'
    Else
    #FXVARTXT := 'PRODUCTTYPE'
    Endif
    
    * Apply markups later
    * * * #MarkupUtility.umApplyMarkup Iretailpricingflag(#LW3MSRPPF) Imarkupapplicationtype(#FXVARTXT) Iorderlinetype(#FXOLNTYP) Imarkupcarpet(#LW3MSRPCP) Imarkuppremaderug(#LW3MSRPPR) Imarkupcustomrug(#LW3MSRPCR) Imarkupcarpettile(#LW3MSRPTL) Imarkuphardsurface(#LW3MSRPHS) Iproducttype(#L00PTYP) Bcalculatedprice(#P010CPRC)
    
    * !NC! - 08/18/2025 - Jan - Not sure why there is logic to ignore dropped products and assuming that the select query below will return more than one record
    * * * * 2021/08/05 - Gitlab#31 - Previously, just load the very first product, but if a product has multiple records and the first one loaded is dropped, check for the next first not-dropped product, but support data if all products are dropped
    * * * If Cond(#L00DROP <> 'Y')
    * * * #wCompletelyDroppedFlag := False
    * * * Endif
    
    Add_Entry To_List(#iProductList)
    
    * !NC! - 08/18/2025 - Jan - Not sure why there is logic to ignore dropped products and assuming that the select query below will return more than one record
    * * * * 2021/08/05 - Gitlab#31 - This should only retrieve one entry, unless the first record is dropped, keep looking for the next undropped item. If all products are dropped, load all of them
    * * * If Cond(#L00DROP <> 'Y')
    * * * Leave
    * * * Endif
    Endselect
    
    * !NC! - 08/18/2025 - Jan - Not sure why there is logic to ignore dropped products and assuming that the select query below will return more than one record
    * * * If Cond(#LISTCOUNT > 0)
    * * * * 2021/08/05 - Gitlab#31 - If every product is dropped, keep only the first record and delete the rest
    * * * If Cond(#wCompletelyDroppedFlag And (#LISTCOUNT > 1))
    * * * #wFirstRecord := True
    * * *
    * * * Selectlist Named(#WL_PRDLST)
    * * * If Cond(#wFirstRecord)
    * * * #wFirstRecord := False
    * * * Else
    * * * Dlt_Entry From_List(#WL_PRDLST)
    * * * Endif
    * * * Endselect
    * * * Else
    * * * * 2021/08/05 - Gitlab#31 - If not all records are dropped, delete the dropped records to load just one record, specifically the only undropped record
    * * * If Cond(*Not #wCompletelyDroppedFlag)
    * * * Selectlist Named(#WL_PRDLST) Where(#L00DROP = Y)
    * * * Dlt_Entry From_List(#WL_PRDLST)
    * * * Endselect
    * * * Endif
    * * * Endif
    * * * Endif
    
    Endroutine
    
    * =======================================================
    * Mthroutine  : umGetDetailsForB2CProduct
    * Description : Read LFIP100to get Product Information for items in B2C
    * =======================================================
    Mthroutine Name(umGetDetailsForB2CProduct) Desc('Get Product Details') Help('Read LFIP100to get Product Information for items in B2C') Access(*PRIVATE)
    
    Define_Map For(*INPUT) Class(#PRIM_LCOL<#CNRPRDDO>) Name(#iProductList) Pass(*BY_REFERENCE)
    Define_Map For(*INPUT) Class(#LW3SFID) Name(#iStorefrontId)
    Define_Map For(*INPUT) Class(#LW3B2BIND) Name(#iStorefrontIndicator)
    Define_Map For(*INPUT) Class(#LW3STYLE) Name(#iStyleCode) Mandatory('')
    Define_Map For(*INPUT) Class(#LW3COLOR) Name(#iColorCode) Mandatory('')
    Define_Map For(*INPUT) Class(#LW3SIZE) Name(#iSizeCode) Mandatory('')
    Define_Map For(*INPUT) Class(#LW3BACK) Name(#iBackingCode) Mandatory('')
    
    Define_Map For(*INPUT) Class(#LW3SDESC) Name(#iStyleDescription) Mandatory('')
    Define_Map For(*INPUT) Class(#LW3CDESC) Name(#iColorDescription) Mandatory('')
    Define_Map For(*INPUT) Class(#PRIM_BOLN) Name(#iSwatchSearch) Mandatory(False)
    
    * * * * No Pricing
    * * *
    * * * * If product detail keys supplied is style and color description (from friendly URL), use them to get product information
    * * * If Cond(#FXFNDURL = 'Y')
    * * *
    * * * If Cond(#FXSWONLY = 'Y')
    * * * * Use color code
    * * * * #134
    * * * #LW3QSEL := "SELECT * FROM LFIP100 AS ATTR"
    * * * #LW3QSEL += " Left Join LFIP100A ATR2 ON ATR2.L0ADVBR = ATTR.L00DVBR And ATR2.L0APCAT = ATTR.L00PCAT And ATR2.L0ACNAME = ATTR.L00CNAME And ATR2.L0ASTYLE = ATTR.L00STYLE And ATR2.L0ACOLOR = ATTR.L00COLOR And ATR2.L0ASIZE = ATTR.L00SIZE And ATR2.L0ABACK = ATTR.L00BACK"
    * * * #LW3QSEL += " WHERE ATTR.L00SDESC = '" + #FXSTYLDS + "' AND ATTR.L00COLOR = '" + #FXCOLRCD + "' " + #COM_OWNER.umAttachFiltersToQuery( True ) + #COM_OWNER.umCheckProprietary
    * * * Else
    * * * * Use color description
    * * * * #134
    * * * #LW3QSEL := "SELECT * FROM LFIP100 AS ATTR"
    * * * #LW3QSEL += " Left Join LFIP100A ATR2 ON ATR2.L0ADVBR = ATTR.L00DVBR And ATR2.L0APCAT = ATTR.L00PCAT And ATR2.L0ACNAME = ATTR.L00CNAME And ATR2.L0ASTYLE = ATTR.L00STYLE And ATR2.L0ACOLOR = ATTR.L00COLOR And ATR2.L0ASIZE = ATTR.L00SIZE And ATR2.L0ABACK = ATTR.L00BACK"
    * * * #LW3QSEL += " WHERE ATTR.L00SDESC = '" + #FXSTYLDS + "' AND ATTR.L00CDESC = '" + #FXCOLRDS + "' " + #COM_OWNER.umAttachFiltersToQuery( True ) + #COM_OWNER.umCheckProprietary
    * * * Endif
    * * *
    * * * Else
    * #134
    #LW3QSEL := "SELECT * FROM LFIP100 AS ATTR"
    #LW3QSEL += " Left Join LFIP100A ATR2 ON ATR2.L0ADVBR = ATTR.L00DVBR And ATR2.L0APCAT = ATTR.L00PCAT And ATR2.L0ACNAME = ATTR.L00CNAME And ATR2.L0ASTYLE = ATTR.L00STYLE And ATR2.L0ACOLOR = ATTR.L00COLOR And ATR2.L0ASIZE = ATTR.L00SIZE And ATR2.L0ABACK = ATTR.L00BACK"
    #LW3QSEL += " WHERE ATTR.L00STYLE = '" + #iStyleCode + "' AND ATTR.L00COLOR = '" + #iColorCode + "' AND ATTR.L00SIZE = '" + #iSizeCode + "' AND ATTR.L00BACK = '" + #iBackingCode + "' " + #COM_OWNER.umCheckProprietary
    * * * Endif
    
    * Exclude swatches from selection
    If Cond(*Not #iSwatchSearch)
    #LW3QSEL += " AND ATTR.L00PTYP NOT IN ('W', 'S')"
    Endif
    
    * AppTracker Issue #12615 - Do not include dropped colors for Premade Rugs
    #LW3QSEL += " AND ((ATTR.L00PTYP <> 'R') Or (ATTR.L00PTYP = 'R' AND L00DROP <> 'Y'))"
    
    Select_Sql Fields(#L00DVBR #L00PCAT #L00CNAME #L00STYLE #L00COLOR #L00SIZE #L00BACK #L00PTYP #L00SDESC #L00CDESC #L00WTHFT #L00WTHIN #L00BDESC #L00STDLTH #L00PRDG #L00F2F #L00DROP #L00DROPDT #L00PROPRI #L00PROPCU #L00PROPB2 #L00CLR1 #L00CLR2 #L00PATRNR #L00CONSTR #L00LOOK #L00USAGE #L00FIBER1 #L00FIBER2 #L00FIBER3 #L00PATERN #L00PAT001 #L00FIBRLB #L00CPYRGT #L00MXWTHF #L00MXWTHI #L00SKUSEQ #L00INTROD #L00IMGFLA #L00IMGPRO #L00RMSCEN #L00RMS001 #L00RMS002 #L00IMGGRO #L00FLATCL #L00FLATRN #L00PROFCL #L00PROFRN #L00RM1CLR #L00RM1RNK #L00RM2CLR #L00RM2RNK #L00RM3CLR #L00RM3RNK #L00GROPCL #L00GROPRN #L00ROLONL #L00RPC #L00PATPRD #L00CHAR1 #L00CHAR2 #L00CHAR3 #L00CHAR4 #L00CHAR5 #L00FLAG1 #L00FLAG2 #L00FLAG3 #L00FLAG4 #L00FLAG5 #L00INT1 #L00INT2 #L00INT3 #L00INT4 #L00INT5 #L00DEC1 #L00DEC2 #L00DEC3 #L00DEC4 #L00DEC5 #L00COLCD #L00ROOMTY #L00ROO001 #L00ROO002 #L00WDTIN #L00LTHIN) Io_Error(*NEXT) Using(#LW3QSEL)
    
    Add_Entry To_List(#iProductList)
    
    Endselect
    
    Endroutine
    
    
    * =======================================================
    * Mthroutine  : umGetProductMainImage
    * Description : Get Product Image
    * =======================================================
    Mthroutine Name(umGetProductMainImage) Desc('Get Product Image') Help('Get Product Image')
    Define_Map For(*INPUT) Class(#LW3ITEMCD) Name(#iItemCode)
    Define_Map For(*OUTPUT) Class(#LW3IATVL) Name(#oImageURL)
    Define_Map For(*OUTPUT) Class(#LW3RETCOD) Name(#oStatus) Mandatory('')
    
    * Fetch Item Image
    Fetch Fields(#LW3IATVL) From_File(LW3IATTRL1) With_Key(#Global_DataModel.upStorefrontId #iItemCode 86 #Global_DataModel.upCurrentLanguage)
    
    * Check if the item is existing in the LW3IATTR
    If_Status Is(*OKAY)
    #oStatus := 'OK'
    #oImageURL := #LW3IATVL
    Else
    #oStatus := 'ER'
    
    Endif
    
    Endroutine
    
    * =======================================================
    * Mthroutine ....: umCheckProprietary
    * Description....: Check Proprietary for B2B and B2C
    * =======================================================
    Mthroutine Name(umCheckProprietary) Desc('Check Proprietary for B2B and B2C') Help('Check Proprietary for B2B and B2C')
    Define_Map For(*INPUT) Class(#C1CGRP) Name(#iCustomerGroupNumber) Mandatory(0)
    Define_Map For(*RESULT) Class(#PRIM_ALPH) Name(#rString)
    
    If Cond(#Global_DataModel.upStorefrontIndicator = 'B')
    #rString += " AND ((ATTR.L00PROPRI <> 'Y') Or ((ATTR.L00PROPRI = 'Y') AND (ATTR.L00PROPCUS IN (" + #L_CustomerIdForQuery + ", " + #iCustomerGroupNumber.asString + "))))"
    Else
    #rString += " AND ((ATTR.L00PROPRI <> 'Y') Or ((ATTR.L00PROPRI = 'Y') AND ((ATTR.L00PROPB2C = 'Y') OR ((ATTR.L00PTYP IN ('S', 'W')) AND (ATTR.L00PROPCUS = " + #Global_DataModel.umGetCustomerIdForQuery + ")))))"
    Endif
    
    Endroutine
    
    * =======================================================
    * Mthroutine ....: umApplyURLFilterToQuery
    * Description....: If URL filter is provided, ensure that the query retrieval is conditioned based on it
    * =======================================================
    Mthroutine Name(umApplyUrlFilterToQuery) Desc('Apply Url Filter to Query') Help('If URL filter is provided, ensure that the query retrieval is conditioned based on it')
    
    Define_Map For(*INPUT) Class(#FXURLFLT) Name(#iSeachType)
    Define_Map For(*RESULT) Class(#LW3QSEL) Name(#rQueryString)
    
    Case Of_Field(#iSeachType)
    
    When Value_Is(= 'RESIDENTIAL')
    * AppTrk #13373 - 07/29/2020 - Include Commercial in Residential Menu Filter
    * #rQueryString := " And ATTR.L00PTYP In ('C', 'N', 'B', 'X', 'R') And ATTR.L00USAGE <> 'COMMERCIAL'"
    #rQueryString := " And ATTR.L00PTYP In ('C', 'N', 'B', 'X', 'R')"
    
    When Value_Is(= 'COMMERCIAL')
    #rQueryString := " And (ATTR.L00PTYP In ('C', 'P', 'T') And ATTR.L00USAGE = 'COMMERCIAL')"
    
    When Value_Is(= 'HARD_SURFACE')
    #rQueryString := " And ATTR.L00PTYP In ('H', 'I')"
    
    When Value_Is(= 'STOCKEDRUG')
    #rQueryString := " And ATTR.L00PTYP = 'R'"
    
    When Value_Is(= 'INDOOROUTDOOR')
    #rQueryString := " And ATTR.L00USAGE = 'INDOOR / OUTDOOR'"
    
    When Value_Is(= 'MOLDING_TRIM')
    #rQueryString := " And ATTR.L00PTYP = 'M'"
    
    * 06/19/2024 - Jan - Adding Laminate Filter
    When Value_Is(= #Global_Constants.upUrlFilter_Laminate)
    #rQueryString := #Global_Constants.upQuery_Filter_Laminate
    
    * Added by Jan - 3rd Nov 2022 - GitLab Issue #227
    When Value_Is(= #Global_Constants.upUrlFilter_Porcelain)
    #rQueryString := #Global_Constants.upQuery_Filter_Porcelain
    
    When Value_Is(= #Global_Constants.upUrlFilter_Ceramic)
    #rQueryString := #Global_Constants.upQuery_Filter_Ceramic
    
    When Value_Is(= #Global_Constants.upUrlFilter_GlassMosaic)
    #rQueryString := #Global_Constants.upQuery_Filter_GlassMosaic
    
    When Value_Is(= #Global_Constants.upUrlFilter_RecycledGlass)
    #rQueryString := #Global_Constants.upQuery_Filter_RecycledGlass
    
    When Value_Is(= #Global_Constants.upUrlFilter_Bullnose)
    #rQueryString := #Global_Constants.upQuery_Filter_Bullnose
    
    * G#131 - Add new URL Filters for the Lux Vinyl Subtypes
    When Value_Is(= #Global_Constants.upUrlFilter_WPC)
    #rQueryString := #Global_Constants.upQuery_Filter_WPC
    
    When Value_Is(= #Global_Constants.upUrlFilter_SPC)
    #rQueryString := #Global_Constants.upQuery_Filter_SPC
    
    * G#151 - Fine Hardwood
    When Value_Is(= #Global_Constants.upUrlFilter_FineHardwood)
    #rQueryString := #Global_Constants.upQuery_Filter_FineHardwood
    
    Endcase
    
    Endroutine
    
    * =======================================================
    * Mthroutine ....: umShouldWeHideInB2BOtherStyles
    * Description....: Should we hide for F2K products
    * =======================================================
    Mthroutine Name(umShouldWeHideInB2BOtherStyles)
    Define_Map For(*INPUT) Class(#L00STYLE) Name(#iStyle)
    Define_Map For(*RESULT) Class(#PRIM_BOLN) Name(#rResult)
    
    * Check if we should flag the style itself first
    #rResult := #COM_OWNER.umShouldWeHideInB2B( #iStyle )
    
    * If not, check the other styles related to it
    If Cond(#rResult = False)
    * Read LFIP134 for similar styles.
    #L134STYL1 #L134STYL2 #L134STYL3 #L134STYL4 #L134STYL5 #L134STYL6 #L134STYL7 #L134STYL8 #L134STYL9 #L134ST001 := *NULL
    
    #LW3QSEL := "Select DISTINCT L134STYL1, L134STYL2, L134STYL3, L134STYL4, L134STYL5, L134STYL6, L134STYL7, L134STYL8, L134STYL9, L134STYL10 "
    #LW3QSEL += " From LFIP134 Where"
    #LW3QSEL += " (L134STYL1 = '" + #iStyle + "') Or "
    #LW3QSEL += " (L134STYL2 = '" + #iStyle + "') Or "
    #LW3QSEL += " (L134STYL3 = '" + #iStyle + "') Or "
    #LW3QSEL += " (L134STYL4 = '" + #iStyle + "') Or "
    #LW3QSEL += " (L134STYL5 = '" + #iStyle + "') Or "
    #LW3QSEL += " (L134STYL6 = '" + #iStyle + "') Or "
    #LW3QSEL += " (L134STYL7 = '" + #iStyle + "') Or "
    #LW3QSEL += " (L134STYL8 = '" + #iStyle + "') Or "
    #LW3QSEL += " (L134STYL9 = '" + #iStyle + "') Or "
    #LW3QSEL += " (L134STYL10 = '" + #iStyle + "')"
    
    Select_Sql Fields(#L134STYL1 #L134STYL2 #L134STYL3 #L134STYL4 #L134STYL5 #L134STYL6 #L134STYL7 #L134STYL8 #L134STYL9 #L134ST001) Io_Error(*NEXT) Using(#LW3QSEL)
    Leave
    Endselect
    
    
    * Call umShouldWeHideInB2B until it finds a hit
    If Cond((#L134STYL1 <> '') And (#rResult = False))
    #rResult := #COM_OWNER.umShouldWeHideInB2B( #L134STYL1 )
    Endif
    
    If Cond((#L134STYL2 <> '') And (#rResult = False))
    #rResult := #COM_OWNER.umShouldWeHideInB2B( #L134STYL2 )
    Endif
    
    If Cond((#L134STYL3 <> '') And (#rResult = False))
    #rResult := #COM_OWNER.umShouldWeHideInB2B( #L134STYL3 )
    Endif
    
    If Cond((#L134STYL4 <> '') And (#rResult = False))
    #rResult := #COM_OWNER.umShouldWeHideInB2B( #L134STYL4 )
    Endif
    
    If Cond((#L134STYL5 <> '') And (#rResult = False))
    #rResult := #COM_OWNER.umShouldWeHideInB2B( #L134STYL5 )
    Endif
    
    If Cond((#L134STYL6 <> '') And (#rResult = False))
    #rResult := #COM_OWNER.umShouldWeHideInB2B( #L134STYL6 )
    Endif
    
    If Cond((#L134STYL7 <> '') And (#rResult = False))
    #rResult := #COM_OWNER.umShouldWeHideInB2B( #L134STYL7 )
    Endif
    
    If Cond((#L134STYL8 <> '') And (#rResult = False))
    #rResult := #COM_OWNER.umShouldWeHideInB2B( #L134STYL8 )
    Endif
    
    If Cond((#L134STYL9 <> '') And (#rResult = False))
    #rResult := #COM_OWNER.umShouldWeHideInB2B( #L134STYL9 )
    Endif
    
    If Cond((#L134ST001 <> '') And (#rResult = False))
    #rResult := #COM_OWNER.umShouldWeHideInB2B( #L134ST001 )
    Endif
    Endif
    
    Endroutine
    
    * * =======================================================
    * * Mthroutine ....: umShouldWeHideInB2B
    * * Description....: Return true if HDEB2C is found for the style/style+color. Pass both the Style and Tile-Style so that even the trims would be removed
    * * =======================================================
    Mthroutine Name(umShouldWeHideInB2B)
    Define_Map For(*INPUT) Class(#L00STYLE) Name(#iStyle)
    Define_Map For(*RESULT) Class(#PRIM_BOLN) Name(#rResult)
    
    #rResult := False
    
    If Cond(#iStyle <> '')
    * If Style is found, Flag true to remove
    Check_For In_File(LW3CODES) With_Key('HDEB2C' #iStyle) Io_Error(*NEXT) Val_Error(*NEXT)
    If_Status Is(*EQUALKEY)
    #rResult := True
    Endif
    Endif
    Endroutine
    
    * ==========================================================================================
    * Mthroutine  : umGetResources
    * Description : Get resources
    * ==========================================================================================
    Mthroutine Name(umGetResources) Desc('Get Resources for the Product Detail Tab')
    Define_Map For(*INPUT) Class(#L00PTYP) Name(#i_L00PTYP)
    Define_Map For(*INPUT) Class(#L00STYLE) Name(#i_L00STYLE)
    Define_Map For(*INPUT) Class(#L00FIBRLB) Name(#i_L00FIBRLB)
    Define_Map For(*INPUT) Class(#L00DVBR) Name(#i_L00DVBR)
    
    Define_Map For(*INPUT) Class(#F54STYP) Name(#i_F54STYP) Mandatory('')
    
    Define_Map For(*OUTPUT) Class(#LW3CDES) Name(#o_FIBER)
    Define_Map For(*OUTPUT) Class(#LW3CDES) Name(#o_CLEANINGANDCARE)
    Define_Map For(*OUTPUT) Class(#LW3CDES) Name(#o_WARRANTY)
    Define_Map For(*OUTPUT) Class(#LW3CDES) Name(#o_INSTALLATIONGUIDE)
    * G#151
    Define_Map For(*OUTPUT) Class(#LW3CDES) Name(#o_SPECSHEET)
    Define_Map For(*OUTPUT) Class(#LW3CDES) Name(#o_TRIMINFO)
    
    * G#88 - add new input field
    Define_Map For(*INPUT) Class(#L00SIZE) Name(#i_L00SIZE) Mandatory('')
    
    Define Field(#W_GETCNTBYCOL) Type(*CHAR) Length(1)
    
    * Retrieve Tab Contents from the B2B Storefront
    * #W_SFID := 9
    * G#151
    * #o_FIBER #o_WARRANTY #o_CLEANINGANDCARE   := *NULL
    #o_FIBER #o_WARRANTY #o_CLEANINGANDCARE #o_INSTALLATIONGUIDE #o_SPECSHEET #o_TRIMINFO := *NULL
    
    * Gitlab #41 - Show warranty tab for both B2B and B2C sites
    * #134 - Do not show tabs for Molding Trim
    * Modified by Jan - 4th Nov 2022 - GitLab Issue #254
    If Cond(*Not (#Global_Constants.umIsCoordinatingProduct( #i_L00PTYP )))
    * Warranty
    #L02WRNTY #L02COLL #W_GETCNTBYCOL := *NULL
    Fetch Fields(#L02WRNTY) From_File(LFIP102) With_Key(#L02COLL #i_L00STYLE) Io_Error(*NEXT) Val_Error(*NEXT)
    If_Status Is(*OKAY)
    #LW3MNUESD := #L02WRNTY
    If Cond((#LW3MNUESD <> *BLANKS) And (#LW3MNUESD <> '1RW'))
    #o_WARRANTY := #Utility_Codes.umGetCodeDescriptionByCode( 'PDFWTY' #LW3MNUESD.UpperCase )
    
    If Cond(#o_WARRANTY.Trim = '-')
    #o_WARRANTY := *NULL
    Endif
    
    If Cond(#o_WARRANTY = *BLANK)
    #W_GETCNTBYCOL := 'W'
    Endif
    Endif
    Else
    #W_GETCNTBYCOL := 'W'
    Endif
    
    If Cond(#W_GETCNTBYCOL = 'W')
    Fetch Fields(#L00COLCD) From_File(LFIL1001) With_Key(#i_L00STYLE) Io_Error(*NEXT) Val_Error(*NEXT)
    Fetch Fields(#L02WRNTY) From_File(LFIP102) With_Key(#L00COLCD) Io_Error(*NEXT) Val_Error(*NEXT)
    If_Status Is(*OKAY)
    #LW3MNUESD := #L02WRNTY
    If Cond((#LW3MNUESD <> *BLANKS) And (#LW3MNUESD <> '1RW'))
    #o_WARRANTY := #Utility_Codes.umGetCodeDescriptionByCode( 'PDFWTY' #LW3MNUESD.UpperCase )
    If Cond(#o_WARRANTY.Trim = '-')
    #o_WARRANTY := *NULL
    Endif
    Endif
    Endif
    Endif
    
    * Cleaning and Care
    * G#131 - If Subtype passed look for the combination of Product Type and Subtype first. If that is blanks, then look for just the product type
    If Cond(#i_F54STYP = '')
    #o_CLEANINGANDCARE := #Utility_Codes.umGetCodeDescriptionByCode( 'CACURL' #i_L00PTYP )
    Else
    #o_CLEANINGANDCARE := #Utility_Codes.umGetCodeDescriptionByCode( 'CACURL' (#i_L00PTYP + '+' + #i_F54STYP) )
    Endif
    
    * Fiber
    If Cond(#i_L00FIBRLB <> *BLANKS)
    #o_FIBER := #Utility_Codes.umGetCodeDescriptionByCode( 'PDFFBR' #i_L00FIBRLB.UpperCase )
    If Cond(#o_FIBER.Trim = '-')
    #o_FIBER := *NULL
    Endif
    Endif
    
    * G#95  Search Installation guide via this heirarchy
    * - Brand+Size e.g F2K+725X48 (the new flavour of code I've suggested), if no match then check,
    * - Product Type e.g C, if no match then check,
    * - Brand e.g F2K, , if no match then check,
    * - Size e.g 4X48
    #o_INSTALLATIONGUIDE := #Utility_Codes.umGetCodeDescriptionByCode( 'ISGURL' (#i_L00DVBR + '+' + #i_L00SIZE) )
    * #COM_OWNER.umSQLDebugMessage( (' umGetResources ') (#i_L00PTYP + '-' + #i_L00STYLE + '-' + #i_L00FIBRLB + '-' + #i_L00DVBR + '-' + #i_L00SIZE + '-' + #L00COLCD) )
    
    If Cond(#o_INSTALLATIONGUIDE = '')
    * Check if installation guide can be retrieved by product type, otherwise by size
    #o_INSTALLATIONGUIDE := #Utility_Codes.umGetCodeDescriptionByCode( 'ISGURL' #i_L00PTYP )
    Endif
    
    * G#220 - If no PDF for Product Type, look via the Brand Code. If there is still no value, look via the Size
    * Modified by Jan - 5th Nov 2022 - GitLab Issue #227 - Do not show for F2K Tiles and Trims
    If Cond((#o_INSTALLATIONGUIDE = '') And ((#i_L00PTYP <> 'M') And (#i_L00PTYP <> #Global_Constants.upPrdTyp_Laminate) And (#i_L00PTYP <> #Global_Constants.upPrdTyp_Porcelain) And (#i_L00PTYP <> #Global_Constants.upPrdTyp_GlassMosaic) And (#i_L00PTYP <> #Global_Constants.upPrdTyp_Bullnose)))
    #o_INSTALLATIONGUIDE := #Utility_Codes.umGetCodeDescriptionByCode( 'ISGURL' #i_L00DVBR )
    Endif
    
    * G#93 - Question About Values Displayed for Tile
    * - Collection Code Check for NVL8 and NMV8
    If Cond(#i_L00PTYP = 'L')
    Fetch Fields(#L00COLCD) From_File(LFIL1001) With_Key(#i_L00STYLE) Io_Error(*NEXT) Val_Error(*NEXT)
    If_Status Is(*OKAY)
    If Cond((#o_INSTALLATIONGUIDE = '') And ((#L00COLCD = 'NVM8') Or (#L00COLCD = 'NVL8')))
    #o_INSTALLATIONGUIDE := #Utility_Codes.umGetCodeDescriptionByCode( 'ISGURL' #L00COLCD )
    Endif
    Endif
    Endif
    
    If Cond(#o_INSTALLATIONGUIDE = '')
    * G#88 - replace key with #i_L00SIZE
    #o_INSTALLATIONGUIDE := #Utility_Codes.umGetCodeDescriptionByCode( 'ISGURL' #i_L00SIZE )
    Endif
    
    Endif
    
    * G#151
    #o_SPECSHEET := #Utility_Codes.umGetCodeDescriptionByCode( 'SPSURL' #i_L00STYLE )
    #o_TRIMINFO := #Utility_Codes.umGetCodeDescriptionByCode( 'TRMURL' #i_L00PTYP )
    
    Endroutine
    
    * =======================================================
    * Mthroutine ....: umGetBrandDescription
    * Description....: Get Brand Description
    * =======================================================
    Mthroutine Name(umGetBrandDescription) Desc('Get Brand Description')
    
    Define_Map For(*INPUT) Class(#L00DVBR) Name(#iBrand)
    Define_Map For(*INPUT) Class(#L00PTYP) Name(#iProductType)
    Define_Map For(*INPUT) Class(#L00STYLE) Name(#iStyleCode)
    Define_Map For(*INPUT) Class(#L00COLOR) Name(#iColorCode)
    Define_Map For(*INPUT) Class(#L00COLOR) Name(#iSizeCode)
    Define_Map For(*INPUT) Class(#L00COLOR) Name(#iBackingCode)
    Define_Map For(*RESULT) Class(#LW3BRNDS) Name(#rBrandDescription)
    
    * Github #122 - 06/21/2024 - New method for retrieving brand description
    
    * G#151
    * If Cond((#iBrand = 'SHS') And (#iProductType = 'L'))
    If Cond((#iBrand = 'SHS') And ((#iProductType = #Global_Constants.upPrdTyp_Laminate) Or (#iProductType = #Global_Constants.upPrdTyp_FineHardwood) Or (#iProductType = #Global_Constants.upPrdTyp_Trim) Or (#iProductType = #Global_Constants.upPrdTyp_GlassMosaic)))
    * For Laminates, Trims, Finehardwood under the Stanton DWF, change the brand displayed to just "Stanton"
    #rBrandDescription := #Utility_Codes.umGetCodeDescriptionByCode( 'BRAND' 'ST' )
    Else
    
    If Cond((#iBrand = 'SHS') And (#Global_Constants.umIsCoordinatingProduct( #iProductType )))
    
    #LW3COUNT5 := 0
    
    #LW3QSEL := "Select Count(*) From FIP351 As COORD"
    #LW3QSEL += " Join LFIP100 As ATTR On ATTR.L00STYLE = COORD.F351STYL And ATTR.L00COLOR = COORD.F351CLR"
    * If the Trim's associated product is a Laminate under the Stanton DWF brand
    #LW3QSEL += " Where COORD.F351MSTYL = '" + #iStyleCode + "' And COORD.F351MCLR = '" + #iColorCode + "' And COORD.F351MSIZE = '" + #iSizeCode + "' And COORD.F351MBACK = '" + #iBackingCode + "'"
    #LW3QSEL += " And ATTR.L00PTYP = '" + #Global_Constants.upPrdTyp_Laminate + "' And ATTR.L00DVBR = 'SHS'"
    
    Select_Sql Fields(#LW3COUNT5) Io_Error(*NEXT) Using(#LW3QSEL)
    Leave
    Endselect
    
    If Cond(#LW3COUNT5 > 0)
    * For Laminates under the Stanton DWF, change the brand displayed to just "Stanton"
    #rBrandDescription := #Utility_Codes.umGetCodeDescriptionByCode( 'BRAND' 'ST' )
    Else
    #rBrandDescription := #Utility_Codes.umGetCodeDescriptionByCode( 'BRAND' #iBrand )
    
    Endif
    
    Else
    #rBrandDescription := #Utility_Codes.umGetCodeDescriptionByCode( 'BRAND' #iBrand )
    
    Endif
    
    Endif
    
    Endroutine
    
    * ==========================================================================================
    * Mthroutine  : umGetProdTypeDescription
    * Description : Get Product Type description
    * ==========================================================================================
    Mthroutine Name(umGetProdTypeDescription)
    Define_Map For(*INPUT) Class(#L00PTYP) Name(#iProductType)
    Define_Map For(*INPUT) Class(#L00PCAT) Name(#iCategory)
    Define_Map For(*INPUT) Class(#L00STYLE) Name(#iStyle)
    Define_Map For(*INPUT) Class(#L00BACK) Name(#iBack)
    Define_Map For(*INPUT) Class(#L00COLOR) Name(#iColor)
    Define_Map For(*INPUT) Class(#L00SIZE) Name(#iSize)
    
    Define_Map For(*RESULT) Class(#PRIM_ALPH) Name(#rProdTypeDesc)
    
    #rProdTypeDesc := *NULL
    
    If Cond(#COM_OWNER.umGetSubType( #iCategory #iProductType #iStyle #iBack ) = '')
    Case Of_Field(#iProductType)
    When Value_Is(= #Global_Constants.upPrdTyp_Porcelain)
    * Use the value found in the HS Masterfile if Product type is porcelain
    #LW3QSEL := "SELECT HSMF.F340CCODE "
    #LW3QSEL += "FROM FIP340 HSMF "
    #LW3QSEL += "WHERE HSMF.F340STYL = '" + #iStyle + "' "
    #LW3QSEL += "  and HSMF.F340CLR = '" + #iColor + "' "
    #LW3QSEL += "  and HSMF.F340SIZE = '" + #iSize + "' "
    #LW3QSEL += "  and HSMF.F340BACK = '" + #iBack + "'"
    
    Select_Sql Fields(#F340CCODE) Io_Error(*NEXT) Using(#LW3QSEL)
    #rProdTypeDesc := #Utility_General.umProperCase( #F340CCODE )
    Leave
    Endselect
    
    When Value_Is(= #Global_Constants.upPrdTyp_GlassMosaic)
    * If Detail Value = RG is found, use the Detail Value. If not then use the Product Type value
    #LW3QSEL := "SELECT XDTL.L130DVAL "
    #LW3QSEL += "FROM LFIP130 XDTL "
    #LW3QSEL += "WHERE XDTL.L130STYL = '" + #iStyle + "' "
    #LW3QSEL += "  and XDTL.L130CLR = '" + #iColor + "' "
    #LW3QSEL += "  and XDTL.L130SIZE = '" + #iSize + "' "
    #LW3QSEL += "  and XDTL.L130BACK = '" + #iBack + "'"
    #LW3QSEL += "  and XDTL.L130DVAL = 'RECYCLED GLASS'"
    
    Select_Sql Fields(#STD_TEXT) Io_Error(*NEXT) Using(#LW3QSEL)
    #rProdTypeDesc := #Utility_General.umProperCase( #STD_TEXT )
    Leave
    Endselect
    
    * Not Recycled Glass, use the Product Type
    If Cond(#rProdTypeDesc = '')
    #rProdTypeDesc := #Utility_Codes.umGetCodeDescriptionByCode( 'PRDTYP' #iProductType )
    Endif
    
    Otherwise
    #rProdTypeDesc := #Utility_Codes.umGetCodeDescriptionByCode( 'PRDTYP' #iProductType )
    Endcase
    Else
    #rProdTypeDesc := #Utility_Codes.umGetCodeDescriptionByCode( 'PRDTYP' (#iProductType + '+' + #COM_OWNER.umGetSubType( #iCategory #iProductType #iStyle #iBack )) )
    Endif
    
    Endroutine
    
    * ==========================================================================================
    * Mthroutine  : umGetSizeDescription
    * Description : Get Size description
    * ==========================================================================================
    Mthroutine Name(umGetSizeDescription)
    Define_Map For(*INPUT) Class(#L00PTYP) Name(#iProductType)
    Define_Map For(*INPUT) Class(#L00STYLE) Name(#iStyle)
    Define_Map For(*INPUT) Class(#L00SIZE) Name(#iSize)
    Define_Map For(*INPUT) Class(#L00COLOR) Name(#iColor)
    Define_Map For(*INPUT) Class(#L00BACK) Name(#iBack)
    
    Define_Map For(*RESULT) Class(#F2WDSC) Name(#rSizeDescription)
    
    Define_Com Class(#PRIM_NMBR) Name(#w_PositionOfX)
    Define_Com Class(#PRIM_NMBR) Name(#w_PositionOfFirstInch)
    Define_Com Class(#PRIM_NMBR) Name(#w_PositionOfLastInch)
    
    * Clear workfields
    #F2WDSC #F2PWTI #F2PLTI #rSizeDescription := *NULL
    
    * Use FIP020T for Trims
    If Cond(#iProductType = #Global_Constants.upPrdTyp_Trim)
    Fetch Fields(#F2PWTI #F2PLTI) From_File(FIP020T) With_Key(#iStyle #iColor #iSize #iBack) Io_Error(*NEXT) Val_Error(*NEXT)
    If_Status Is(*OKAY)
    #rSizeDescription := ('&1"W X &2"L').TrimSubstitute( #F2PWTI.AsDisplayString( EditCode_N ) #F2PLTI.AsDisplayString( EditCode_N ) )
    Endif
    Else
    * G#4 - Use the FIP020.F2WDSC for the dimension rather than building the value from LFIP100's length and width fields
    If Cond(#Global_Constants.umIsCoordinatingProduct( #iProductType ) Or #Global_Constants.umIsHardSurface( #iProductType ))
    Fetch Fields(#F2WDSC) From_File(FIL020A1) With_Key(#iStyle #iSize #iColor #iBack) Io_Error(*NEXT) Val_Error(*NEXT)
    If_Status Is(*OKAY)
    #rSizeDescription := #F2WDSC
    
    * G#144
    * a) Look for a 'W' in the F2WDSC field value. If found, then take no further action, return the F2WDSC dimension data unchanged.
    If Cond(*Not #rSizeDescription.UpperCase.Contains( 'W' ))
    * b) If a 'W' is not found in the F2WDSC string, now look for an 'X'. If not found, just return the dimension as-is unchanged (this is an unexpected format which we will not process further).
    * If Cond(*Not #F2WDSC.UpperCase.Contains( ' X ' ))
    If Cond(#rSizeDescription.UpperCase.Contains( 'X' ))
    * c) If an 'X' is found, check if the character before and after the 'X' is a space. If no space(s) found insert space(s) before and after the 'X'.
    #w_PositionOfX := #rSizeDescription.UpperCase.PositionOf( 'X' )
    
    If Cond(#w_PositionOfX > 1)
    If Cond(#rSizeDescription.UpperCase.Substring( (#w_PositionOfX - 1) 1 ) <> *BLANK)
    #rSizeDescription := #rSizeDescription.ReplaceAll( 'X' ' X ' )
    Endif
    
    * d) Next, look for the first inch symbol " then immediately after that include a "W".
    * e) Finally, look for the next/last inch symbol " then immediately after include a "L".
    #w_PositionOfFirstInch := #rSizeDescription.UpperCase.PositionOf( '"' )
    
    If Cond((#w_PositionOfFirstInch > 0) And (#w_PositionOfFirstInch < #rSizeDescription.CurChars))
    * G#151
    If Cond(#rSizeDescription.UpperCase.Substring( (#w_PositionOfFirstInch + 1) 1 ) <> "W")
    * #rSizeDescription := #rSizeDescription.Substring( 1 #w_PositionOfFirstInch ) + 'W' + #rSizeDescription.Substring( (#w_PositionOfFirstInch + 1) ) + 'L'
    
    * f) Some Fine Hardwood have RL at the end. If that is the case, no need to add an L, but remove the space between the values
    If Cond((#rSizeDescription.UpperCase.Contains( 'RL' )))
    #rSizeDescription := #rSizeDescription.ReplaceAll( ' RL' 'RL' )
    #rSizeDescription := #rSizeDescription.Substring( 1 #w_PositionOfFirstInch ) + 'W' + #rSizeDescription.Substring( (#w_PositionOfFirstInch + 1) )
    Else
    * g) According to Christine, @MarcusLancaster not necessary to show FXD can be L. thus we remove the FXD before padding the L
    If Cond(#rSizeDescription.UpperCase.Contains( 'FXD' ))
    #rSizeDescription := #rSizeDescription.RemoveAll( 'FXD' )
    Endif
    
    #rSizeDescription := #rSizeDescription.Substring( 1 #w_PositionOfFirstInch ) + 'W' + #rSizeDescription.Substring( (#w_PositionOfFirstInch + 1) ) + 'L'
    Endif
    Endif
    Endif
    Endif
    Endif
    * Endif
    Endif
    Endif
    Endif
    Endif
    
    Endroutine
    
    * =======================================================
    * Mthroutine ....: umGetSubType
    * Description....: Get Subtype value if available
    * =======================================================
    Mthroutine Name(umGetSubType)
    Define_Map For(*INPUT) Class(#L00PCAT) Name(#iCategory)
    Define_Map For(*INPUT) Class(#L00PTYP) Name(#iProductType)
    Define_Map For(*INPUT) Class(#L00STYLE) Name(#iStyle)
    Define_Map For(*INPUT) Class(#L00BACK) Name(#iBacking)
    Define_Map For(*RESULT) Class(#F54STYP) Name(#rSubtype)
    
    #rSubtype := *NULL
    
    #LW3QSEL := " SELECT F54STYP FROM FIP054 "
    #LW3QSEL += " WHERE F54PCAT = '" + #iCategory + "' and F54PTYP = '" + #iProductType + "' "
    #LW3QSEL += " and F54STYL = '" + #iStyle + "' and F54BACK = '" + #iBacking + "'"
    
    Select_Sql Fields(#F54STYP) Io_Error(*NEXT) Using(#LW3QSEL)
    #rSubtype := #F54STYP
    Leave
    Endselect
    Endroutine
    
    * =======================================================
    * Mthroutine ....: umGetExtendedSKUDetails
    * Description....: Get Extended SKU Details
    * =======================================================
    Mthroutine Name(umGetExtendedSKUDetails) Desc('Get Extended SKU Details')
    Define_Map For(*INPUT) Class(#LW3STYLE) Name(#iStyle) Desc('Style')
    Define_Map For(*INPUT) Class(#LW3COLOR) Name(#iColor) Desc('Color')
    Define_Map For(*INPUT) Class(#LW3SIZE) Name(#iSize) Desc('Size')
    Define_Map For(*INPUT) Class(#LW3BACK) Name(#iBack) Desc('Back')
    
    * G#157
    Define_Map For(*INPUT) Class(#LW3PTYP) Name(#iProductType) Desc('Product Type')
    
    Define_Map For(*OUTPUT) Class(#PRIM_LCOL<#LW3ESKUD>) Name(#o_ExtendedDetailList) Pass(*BY_REFERENCE)
    
    * Clear and populate collections
    Set_Ref Com(#o_ExtendedDetailList) To(*CREATE_AS #PRIM_LCOL<#LW3ESKUD>)
    
    Clr_List Named(#o_ExtendedDetailList)
    
    #LW3QSEL := "Select L130DTYP, LISTAGG(TRIM(L130DVAL), ', ') Within Group (Order By L130SEQ#) As DetailValue"
    #LW3QSEL += " From LFIP130"
    #LW3QSEL += " Where L130STYL = '" + #iStyle + "' And L130CLR = '" + #iColor + "' And L130SIZE = '" + #iSize + "' And L130BACK = '" + #iBack + "'"
    #LW3QSEL += " Group By L130DTYP"
    
    Select_Sql Fields(#L130DTYP #LW3DTLVL) Io_Error(*NEXT) Using(#LW3QSEL)
    * G#157 - Skip Overall Thickness for Fine Hardwood. This can be done in the data as well
    Continue If((#iProductType = #Global_Constants.upPrdTyp_FineHardwood) And (#L130DTYP.UpperCase = 'OVERALL THICKNESS'))
    
    #LW3DTLVL := #Utility_General.umProperCase( #LW3DTLVL )
    
    Add_Entry To_List(#o_ExtendedDetailList)
    Endselect
    
    Endroutine
    
    End_Com
